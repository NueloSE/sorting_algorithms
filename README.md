![Sorting-in-C](https://github.com/El-gibbor/sorting_algorithms/assets/107848793/a99be5dc-eef6-43f4-a7d0-8d499439be24)  
# Sorting Algorithm & Big O   
Sorting algorithms and Big O notation are foundational concepts in computer science. It empowers one to write efficient code and make informed decisions about algorithm selection based on the characteristics of the data.  
## Learning Objectives üìö
Upon completing this project,the goal is to be capable of elucidating the below concepts to anyone, independently and without reliance on external resources:  
* Understand and explain at least four different sorting algorithms.
* Grasp the concept of Big O notation and be able to evaluate the time complexity of an algorithm.
* Learn how to select the best sorting algorithm for a given input.
* Comprehend the concept of a stable sorting algorithm.
## Big O Notation ‚è±
Big O notation is a way to describe the upper bound of an algorithm's time complexity in relation to the size of its input. It helps us analyze and compare algorithms in terms of their efficiency and scalability. Common Big O complexities include `O(1)`, `O(log n)`, `O(n)`, `O(n log n)`, `O(n^2)`, and more.   
## At least 4 different sorting algorithms  
__1. Bubble Sort__  
Bubble Sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. It has a worst-case time complexity of `O(n^2)`.  
__2. Insertion Sort__  
Insertion Sort builds the final sorted array one item at a time. It is much less efficient on large lists than more advanced algorithms such as Quick Sort or Merge Sort. Its worst-case time complexity is `O(n^2)`.  
__3. Merge Sort__  
Merge Sort is an efficient, stable, and comparison-based sorting algorithm. It divides the unsorted list into n sublists, each containing one element, and then repeatedly merges sublists to produce new sorted sublists until there is only one sublist remaining. It has a worst-case time complexity of `O(n log n)`.  
__4. Quick Sort__  
Quick Sort is a fast and efficient sorting algorithm that uses a divide-and-conquer approach. It selects a 'pivot' element and partitions the array into two sub-arrays - elements less than the pivot and elements greater than the pivot. It then recursively sorts the sub-arrays. On average, it has a time complexity of O(n log n), but its worst-case time complexity is `O(n^2)`.  
## Resources   
[Sorting Algorithms](https://www.youtube.com/playlist?list=PLzZR2BJ8ICYu_832OWSsKtt76PCuxLNZ8) - Youtube Playlist  
[Sorting Algos](https://www.youtube.com/playlist?list=PLuZ_bd9XlByzTIP5j1aWXo7smCIxvzd2D) - Jenny's Lectures  
[CS50 Algorithm explanation](https://intranet.alxswe.com/rltoken/Ea93HeEYuNkOL7sGb6zzGg) - David Malan
